# vue

```html
//声明式渲染
<h2 :title="title"></h2>

//条件
<p v-if="off">显示</p>

//指令

<p @click="handle">点击事件</p>
<p v-model="msg">双向绑定</p>

```

## 原理

```javascript
//路由单页实现原理：
hash模式：利用onhashchang事件;
hishtory模式：利用H5 hishtory interface中pushStage()与replaceSteta()方法；

//v-show
v-show会生成vnode,render时会渲染成真实节点，过程中会修改属性display值;

//v-if
v-if会调用addifCondition方法生成vnode时过滤对应节点，render时不会渲染;

//v-html
v-html会先移除节点内所有节点，通过addprop添加innerHTML属性;


```



## 组件

- 解耦，每个组件为单一的项目，对外只提供接口
- 复用、扩展性强

```javascript
//组件构建
Vue.component('list-item',{
	props:['data'],
  template:'<li>{{datas.name}}</li>'
})

//模板
<div id="app">
  <ol>
      <list-item 
        v-for="(item,index) in groceryList"
        :data="item"
        :key="index"> 
      <list-item>
  </ol>
</div>

//实例化
var app = new Vue({
  el: '#app',
  data: {
    groceryList: [
      { id: 0, name: '蔬菜' },
      { id: 1, name: '奶酪' },
      { id: 2, name: '随便其它什么人吃的东西' }
    ]
  }
})
```

### 动态组件

```typescript
当Tab切时，保留组件状态避免重新渲染
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```

### 异步组件

```javascript
解决大型应用中将应用分割成小代码块，按需从服务器加载
defineAsyncComponent 方法

//动态导入
import { defineAsyncComponent } from 'vue'
const AsyncComp = defineAsyncComponent(() =>
  import('./components/AsyncComponent.vue')
)

app.component('async-component', AsyncComp)


//注册
import { createApp, defineAsyncComponent } from 'vue'
createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =>
      import('./components/AsyncComponent.vue')
    )
  }
})
```

### Mixin组件分发

- 当方法名、键名与组件内重名时，会被组件内覆盖

```javascript
//mixin.js
const mixin = {
  data() {
    return {
      hello: 'hello Mixin'
    }
  },
  created() {
    console.log('在mixin中vue的data、生命周期、方法等都可以使用');
  },
  methods: {
    hello() {
      console.log(this.hello);
    }
  }
}
export default mixin;

使用:
// 1. 局部使用
import mixin from '@/mixin/mixin';
<script>
export default {
  mixins: [mixin],
  created(){
    console.log(this.$date)
  }
}
</script>

// 2.全局使用 main.js
import mixin from '@/mixin/mixin';
Vue.Mixin(mixin)
```



## 通信

- props|$emit()

  - 用于父子组件（只有一层关系）

- provide|inject

  - 用于深度嵌套组件，默认不是响应式

  - 解决响应式，分配一个组合式 API `computed`

    ```javascript
     provide() {
        return {
          todoLength: Vue.computed(() => 													this.todos.length)
        }
      }
    ```

    

- ![attrs/](https://math.jianshu.com/math?formula=attrs%2F)listeners（只适合多级组件数据传递，不做任何处理）

- vuex（适合大项目组件，业务逻辑复杂）

- bus（var bus=new Vue）



## 2.0与3.0区别

- 目录结构

  - 3.0移除配置文件目录、config、build、static文件
  - 3.0新增了public文件

- 渲染

  - 2.0使用虚拟dom实现渲染
  - 3.0会通过h函数判断，如果为原生html标签通过虚拟dom渲染，如果为组件直接生成组件代码

  

- 数据监听
  - 2.0基于object.defineproperties中getter和setter实现的
  - 3.0基于proxy按需监听
- 按需引入
  - 2.0中new出实例对象，所有东西都在这个vue对象上，这样无论是否用到都会跑一次
  - 3.0中用ES module inports按需引入，如keep-alive内置组件、v-model指令等



## 自定义指令

```javascript
/结构：
<input v-focus /> 

/js:
directives:{
  focus:{
		bind(el,binding,vnode,oldVnode){
      //调用时
    },
    inserted(el,binding,vnode,oldVnode){
      //插入父节点时
    },
    updata(el,binding,vnode,oldVnode){
      //更新时
    },
      
  }
}
```



## 3.0开发

- 官方文档：https://v3.cn.vuejs.org/guide/instance.html



### 子项目配置

https://blog.csdn.net/qq_41725450/article/details/105771942



### setup函数

- 可用作组合式API,简化大型应用组件理解和复杂维护

- setup(props,context)两个参数
  - props不能使用ES6解构，会消除数据响应性

- 执行时组件实例尚未被创建，没有this，只能访问：
  - props|attrs|slots|emit
- 生命周期
  - 开始创建组件---- - setup()
  - 组件挂载到页面之前执行---- - onBeforeMount()
  - 组件挂载到页面之后执行---- - onMounted()
  - 组件更新之前---- - onBeforeUpdate()
  - 组件更新之后---- - onUpdated()
    

```javascript
export default {
  setup(props, context) {
    // Attribute (非响应式对象)
    console.log(context.attrs)
    // 插槽 (非响应式对象)
    console.log(context.slots)
    // 触发事件 (方法)
    console.log(context.emit)
  }
}

//使用
import {ref,toRefs,toRef,onMounted,watch,computed,reactive } from 'vue'
setup(props) {
   //toRefs用于解构
	const { title } = toRefs(props)
	console.log(title.value)
  
  //toRef创建，传入的 props 中可能没有 title
  const title = toRef(props, 'title')
	console.log(title.value)
  
  //ref响应式变量
  const repositories = ref([])
  const getUserRepositories = async () => {
    repositories.value = 
      await fetchUserRepositories(props.user)
  }
  
  //reactive函数，定义一个对象
  const data = reactive({
      count: 0,
      changeCount: () => {
        data.count++;
      },
    });
  
  // 在 `mounted` 时调用 `getUserRepositories`
  onMounted(getUserRepositories)
  
  // 在用户 prop 的响应式引用上设置一个侦听器
  watch(title, getUserRepositories)
  
  //computed 函数
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() => {
    return repositories.value.filter(
      repository => repository.name.includes(searchQuery.value)
    
  
  return{
    repositories,
    getUserRepositories,
    searchQuery,
    repositoriesMatchingSearchQuery
    title}
}



```



### 类组件

https://class-component.vuejs.org/guide/class-component.html#data

-  vue-class-componet类装饰器
  - 支持es6Class开发组件的vue官方库,并使组件具有继承、混入等特性



### Ts语法

https://blog.csdn.net/weixin_41308072/article/details/108994027

```



```









